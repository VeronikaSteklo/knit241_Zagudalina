package org.knit.solutions;


import org.knit.TaskDescription;
import org.knit.solutions.task19.MergingSorter;

/*
Условие задачи:

Даны два целочисленных массива nums1 и nums2, отсортированных в неубывающем порядке, а также два целых числа m и n, представляющих количество элементов в nums1 и nums2 соответственно.

Требуется:
Объединить nums1 и nums2 в один массив, отсортированный в неубывающем порядке.

Важные условия:

Итоговый отсортированный массив должен быть сохранён внутри массива nums1 (функция не должна ничего возвращать).
Массив nums1 имеет длину m + n, где:
Первые m элементов — значимые (их нужно объединять с nums2).
Последние n элементов заполнены нулями и должны быть проигнорированы.
Длина nums2 равна n.
Пример 1:

Входные данные:
nums1 = [1, 2, 3, 0, 0, 0], m = 3
nums2 = [2, 5, 6], n = 3

Результат:
[1, 2, 2, 3, 5, 6]

Объяснение:
Объединяемые массивы: [1, 2, 3] и [2, 5, 6].
Результат — [1, 2, 2, 3, 5, 6] (подчёркнутые элементы взяты из nums1).

Пример 2:

Входные данные:
nums1 = [1], m = 1
nums2 = [], n = 0

Результат:
[1]

Объяснение:
Объединяемые массивы: [1] и [].
Результат — [1].

Пример 3:

Входные данные:
nums1 = [0], m = 0
nums2 = [1], n = 1

Результат:
[1]

Объяснение:
Объединяемые массивы: [] и [1].
Поскольку m = 0, в nums1 нет значимых элементов (нули служат только для резерва места).

Ограничения:

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-10^9 <= nums1[i], nums2[j] <= 10^9
Примечания:

Нельзя использовать дополнительную память для создания нового массива (кроме временных переменных).
Решение должно работать за линейное время O(m + n).
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {

    }
}
Напишите решение, а затем Напишите JUnit тесты для проверки решения

Тесты должны покрывать

--Обычные случаи (слияние с данными и без).

--Краевые случаи (пустые массивы, все элементы в одном массиве).

--Отрицательные числа и дубликаты.

--Производительность (большие массивы) // просто зафиксировать время выполнения по производительности эмпирическим путем.
 */

@TaskDescription(taskNumber = 19, taskDescription = "Задача № 19")
public class Task19 implements Solution {

    @Override
    public void execute() {
        MergingSorter mergingSorter = new MergingSorter();

        int[] nums1 = new int[]{1, 2, 3, 0, 0, 0};
        int[] nums2 = new int[]{2, 5, 6};
        mergingSorter.mergeWithSorting(nums1, nums2, nums1.length, nums2.length);
        mergingSorter.printArray(nums1);
    }
}
